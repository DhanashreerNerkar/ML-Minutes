<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Means Clustering - Complete Visual Guide with Examples</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            padding: 60px 30px;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 30px;
            margin-bottom: 40px;
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.15);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: linear-gradient(90deg, #ec4899, #8b5cf6, #3b82f6, #10b981, #f59e0b);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .header h1 {
            font-size: 3.5em;
            background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 15px;
            animation: fadeInUp 0.8s ease;
        }

        .nav-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 40px;
            justify-content: center;
        }

        .nav-tab {
            padding: 15px 30px;
            background: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .nav-tab:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
        }

        .nav-tab.active {
            background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%);
            color: white;
        }

        .content-section {
            display: none;
            animation: fadeInUp 0.6s ease;
        }

        .content-section.active {
            display: block;
        }

        .card {
            background: white;
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
        }

        .section-title {
            font-size: 2.2em;
            margin-bottom: 25px;
            color: #1a1a1a;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .icon-box {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #8b5cf6, #ec4899);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }

        .visual-demo {
            background: linear-gradient(135deg, #f5f7fa 0%, #e9ecef 100%);
            border-radius: 15px;
            padding: 30px;
            margin: 25px 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .concept-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }

        .concept-card {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border-left: 4px solid #3b82f6;
            border-radius: 10px;
            padding: 20px;
            transition: transform 0.3s ease;
        }

        .concept-card:hover {
            transform: translateX(5px);
        }

        .algorithm-step {
            background: linear-gradient(135deg, #fef3c7, #fed7aa);
            border: 2px solid #f59e0b;
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            position: relative;
            padding-left: 60px;
        }

        .step-number {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            width: 35px;
            height: 35px;
            background: #f59e0b;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .formula-box {
            background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%);
            color: white;
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            text-align: center;
            font-size: 1.3em;
            font-weight: 600;
            box-shadow: 0 10px 25px rgba(139, 92, 246, 0.3);
        }

        .code-block {
            background: #1e293b;
            color: #e2e8f0;
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
            overflow-x: auto;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.8;
            position: relative;
        }

        .code-block::before {
            content: 'Python';
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(99, 102, 241, 0.2);
            color: #818cf8;
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 0.8em;
        }

        .pros-cons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 25px 0;
        }

        .pros, .cons {
            padding: 25px;
            border-radius: 15px;
        }

        .pros {
            background: linear-gradient(135deg, #d4f4dd 0%, #bbf7d0 100%);
            border: 2px solid #22c55e;
        }

        .cons {
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
            border: 2px solid #ef4444;
        }

        .real-example {
            background: linear-gradient(135deg, #e0e7ff 0%, #c7d2fe 100%);
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
            border: 2px solid #6366f1;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .comparison-table th {
            background: linear-gradient(135deg, #8b5cf6, #ec4899);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        .comparison-table td {
            padding: 15px;
            border-bottom: 1px solid #e5e7eb;
        }

        .cluster-visual {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 30px 0;
            flex-wrap: wrap;
            gap: 20px;
        }

        .cluster-item {
            text-align: center;
            padding: 20px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            min-width: 150px;
        }

        .cluster-color {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 auto 15px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .interactive-demo {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin: 25px 0;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        .slider-container {
            margin: 20px 0;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #e2e8f0;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: linear-gradient(135deg, #8b5cf6, #ec4899);
            cursor: pointer;
        }

        .warning-box {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            border: 2px solid #f59e0b;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            display: flex;
            align-items: start;
            gap: 15px;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
            .header h1 { font-size: 2.5em; }
            .pros-cons { grid-template-columns: 1fr; }
            .concept-grid { grid-template-columns: 1fr; }
        }
    </style>
    <script>
        function showSection(event, sectionId) {
            const sections = document.querySelectorAll('.content-section');
            sections.forEach(section => {
                section.classList.remove('active');
            });
            
            document.getElementById(sectionId).classList.add('active');
            
            const tabs = document.querySelectorAll('.nav-tab');
            tabs.forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        function updateKMeans() {
            const k = document.getElementById('kValue').value;
            document.getElementById('kDisplay').textContent = k;
            
            // Update visualization
            drawClusters(k);
        }

        function drawClusters(k) {
            const canvas = document.getElementById('clusterCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Colors for clusters
            const colors = ['#ec4899', '#8b5cf6', '#3b82f6', '#10b981', '#f59e0b', '#ef4444'];
            
            // Generate random cluster centers
            const centers = [];
            for (let i = 0; i < k; i++) {
                centers.push({
                    x: Math.random() * (width - 100) + 50,
                    y: Math.random() * (height - 100) + 50
                });
            }
            
            // Generate points around each center
            for (let i = 0; i < k; i++) {
                ctx.fillStyle = colors[i % colors.length];
                
                // Draw cluster points
                for (let j = 0; j < 20; j++) {
                    const angle = (Math.PI * 2 * j) / 20;
                    const radius = Math.random() * 40 + 10;
                    const x = centers[i].x + Math.cos(angle) * radius;
                    const y = centers[i].y + Math.sin(angle) * radius;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // Draw centroid
                ctx.fillStyle = '#000';
                ctx.strokeStyle = colors[i % colors.length];
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centers[i].x, centers[i].y, 8, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // Label
                ctx.fillStyle = '#000';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`C${i+1}`, centers[i].x, centers[i].y - 15);
            }
        }

        window.onload = function() {
            updateKMeans();
        };
    </script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ K-Means Clustering</h1>
            <p>Unsupervised Learning - Group Similar Data Points Together!</p>
        </div>

        <div class="nav-tabs">
            <button class="nav-tab active" onclick="showSection(event, 'fundamentals')">üìä Fundamentals</button>
            <button class="nav-tab" onclick="showSection(event, 'algorithm')">‚öôÔ∏è Algorithm</button>
            <button class="nav-tab" onclick="showSection(event, 'implementation')">üíª Implementation</button>
            <button class="nav-tab" onclick="showSection(event, 'choosing-k')">üî¢ Choosing K</button>
            <button class="nav-tab" onclick="showSection(event, 'realworld')">üåç Real World</button>
            <button class="nav-tab" onclick="showSection(event, 'advanced')">üöÄ Advanced</button>
        </div>

        <!-- Fundamentals Section -->
        <div id="fundamentals" class="content-section active">
            
            <div class="card">
                <h2 class="section-title">
                    <span class="icon-box">üéØ</span>
                    What is K-Means Clustering?
                </h2>
                
                <p style="font-size: 1.2em; line-height: 1.8; color: #475569; margin-bottom: 20px;">
                    K-Means is an unsupervised learning algorithm that groups similar data points into K clusters. 
                    It's like organizing a messy room - you group similar items together without being told what the groups should be!
                </p>

                <div class="visual-demo">
                    <svg width="600" height="400" viewBox="0 0 600 400">
                        <!-- Title -->
                        <text x="300" y="30" text-anchor="middle" font-size="18" font-weight="bold" fill="#333">
                            K-Means Clustering Process
                        </text>
                        
                        <!-- Before Clustering -->
                        <g transform="translate(0, 50)">
                            <text x="150" y="20" text-anchor="middle" font-weight="bold" fill="#666">Before Clustering</text>
                            <rect x="50" y="30" width="200" height="150" fill="#f8f9fa" stroke="#ddd"/>
                            
                            <!-- Random points -->
                            <circle cx="80" cy="60" r="5" fill="#6b7280"/>
                            <circle cx="120" cy="80" r="5" fill="#6b7280"/>
                            <circle cx="100" cy="100" r="5" fill="#6b7280"/>
                            <circle cx="180" cy="140" r="5" fill="#6b7280"/>
                            <circle cx="200" cy="120" r="5" fill="#6b7280"/>
                            <circle cx="220" cy="150" r="5" fill="#6b7280"/>
                            <circle cx="90" cy="140" r="5" fill="#6b7280"/>
                            <circle cx="110" cy="150" r="5" fill="#6b7280"/>
                            <circle cx="70" cy="120" r="5" fill="#6b7280"/>
                            <circle cx="160" cy="70" r="5" fill="#6b7280"/>
                            <circle cx="180" cy="80" r="5" fill="#6b7280"/>
                            <circle cx="140" cy="90" r="5" fill="#6b7280"/>
                            
                            <text x="150" y="200" text-anchor="middle" font-size="12" fill="#666">Unorganized Data</text>
                        </g>
                        
                        <!-- Arrow -->
                        <path d="M 280 150 L 320 150" stroke="#666" stroke-width="3" marker-end="url(#arrowhead)"/>
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                                <polygon points="0 0, 10 3, 0 6" fill="#666"/>
                            </marker>
                        </defs>
                        
                        <!-- After Clustering -->
                        <g transform="translate(350, 50)">
                            <text x="150" y="20" text-anchor="middle" font-weight="bold" fill="#666">After K-Means (K=3)</text>
                            <rect x="50" y="30" width="200" height="150" fill="#f8f9fa" stroke="#ddd"/>
                            
                            <!-- Cluster 1 (purple) -->
                            <circle cx="80" cy="60" r="5" fill="#8b5cf6"/>
                            <circle cx="90" cy="70" r="5" fill="#8b5cf6"/>
                            <circle cx="100" cy="65" r="5" fill="#8b5cf6"/>
                            <circle cx="85" cy="80" r="5" fill="#8b5cf6"/>
                            <circle cx="90" cy="70" r="8" fill="#000" stroke="#8b5cf6" stroke-width="2"/>
                            
                            <!-- Cluster 2 (pink) -->
                            <circle cx="180" cy="140" r="5" fill="#ec4899"/>
                            <circle cx="200" cy="120" r="5" fill="#ec4899"/>
                            <circle cx="220" cy="150" r="5" fill="#ec4899"/>
                            <circle cx="190" cy="135" r="5" fill="#ec4899"/>
                            <circle cx="200" cy="135" r="8" fill="#000" stroke="#ec4899" stroke-width="2"/>
                            
                            <!-- Cluster 3 (blue) -->
                            <circle cx="160" cy="70" r="5" fill="#3b82f6"/>
                            <circle cx="180" cy="80" r="5" fill="#3b82f6"/>
                            <circle cx="140" cy="90" r="5" fill="#3b82f6"/>
                            <circle cx="170" cy="85" r="5" fill="#3b82f6"/>
                            <circle cx="160" cy="80" r="8" fill="#000" stroke="#3b82f6" stroke-width="2"/>
                            
                            <text x="150" y="200" text-anchor="middle" font-size="12" fill="#666">3 Distinct Groups</text>
                        </g>
                        
                        <!-- Legend -->
                        <g transform="translate(200, 280)">
                            <circle cx="10" cy="10" r="5" fill="#6b7280"/>
                            <text x="20" y="14" font-size="12" fill="#666">Data Point</text>
                            
                            <circle cx="10" cy="30" r="8" fill="#000" stroke="#8b5cf6" stroke-width="2"/>
                            <text x="20" y="34" font-size="12" fill="#666">Centroid</text>
                            
                            <rect x="0" y="45" width="15" height="15" fill="#8b5cf6" opacity="0.3"/>
                            <text x="20" y="56" font-size="12" fill="#666">Cluster Region</text>
                        </g>
                    </svg>
                </div>

                <div class="concept-grid">
                    <div class="concept-card">
                        <h4>üéØ Goal</h4>
                        <p>Partition n data points into k clusters where each point belongs to the cluster with the nearest centroid</p>
                    </div>
                    <div class="concept-card">
                        <h4>üìè Distance Metric</h4>
                        <p>Usually Euclidean distance: d = ‚àö[(x‚ÇÇ-x‚ÇÅ)¬≤ + (y‚ÇÇ-y‚ÇÅ)¬≤]</p>
                    </div>
                    <div class="concept-card">
                        <h4>üé® Unsupervised</h4>
                        <p>No labels needed! The algorithm finds patterns on its own</p>
                    </div>
                    <div class="concept-card">
                        <h4>‚ö° Optimization</h4>
                        <p>Minimizes within-cluster sum of squares (WCSS/Inertia)</p>
                    </div>
                    <div class="concept-card">
                        <h4>üîÑ Iterative</h4>
                        <p>Alternates between assigning points and updating centroids</p>
                    </div>
                    <div class="concept-card">
                        <h4>üé≤ Non-deterministic</h4>
                        <p>Different initializations can lead to different results</p>
                    </div>
                </div>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Advantages</h4>
                        <ul style="margin-left: 20px; line-height: 1.8;">
                            <li>Simple and easy to understand</li>
                            <li>Fast and efficient (O(nkt))</li>
                            <li>Works well with spherical clusters</li>
                            <li>Scalable to large datasets</li>
                            <li>Guaranteed to converge</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ùå Limitations</h4>
                        <ul style="margin-left: 20px; line-height: 1.8;">
                            <li>Must specify K in advance</li>
                            <li>Sensitive to initial centroids</li>
                            <li>Assumes spherical clusters</li>
                            <li>Sensitive to outliers</li>
                            <li>May converge to local minimum</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2 class="section-title">
                    <span class="icon-box">üìä</span>
                    Key Concepts
                </h2>

                <div class="formula-box">
                    Objective: Minimize WCSS = Œ£·µ¢ Œ£‚±º ||x‚±º - Œº·µ¢||¬≤
                    <br>
                    <span style="font-size: 0.8em;">where x‚±º is a point in cluster i, and Œº·µ¢ is the centroid of cluster i</span>
                </div>

                <div class="cluster-visual">
                    <div class="cluster-item">
                        <div class="cluster-color" style="background: #ec4899;"></div>
                        <h4>Cluster 1</h4>
                        <p>Centroid: (xÃÑ‚ÇÅ, »≥‚ÇÅ)</p>
                    </div>
                    <div class="cluster-item">
                        <div class="cluster-color" style="background: #8b5cf6;"></div>
                        <h4>Cluster 2</h4>
                        <p>Centroid: (xÃÑ‚ÇÇ, »≥‚ÇÇ)</p>
                    </div>
                    <div class="cluster-item">
                        <div class="cluster-color" style="background: #3b82f6;"></div>
                        <h4>Cluster 3</h4>
                        <p>Centroid: (xÃÑ‚ÇÉ, »≥‚ÇÉ)</p>
                    </div>
                </div>
            </div>

        </div>

        <!-- Algorithm Section -->
        <div id="algorithm" class="content-section">
            
            <div class="card">
                <h2 class="section-title">
                    <span class="icon-box">‚öôÔ∏è</span>
                    The K-Means Algorithm
                </h2>

                <div class="algorithm-step">
                    <span class="step-number">1</span>
                    <h4>Initialize K Centroids</h4>
                    <p>Randomly select K data points as initial centroids (or use K-Means++ for smarter initialization)</p>
                </div>

                <div class="algorithm-step">
                    <span class="step-number">2</span>
                    <h4>Assign Points to Nearest Centroid</h4>
                    <p>Calculate distance from each point to all centroids, assign to nearest one</p>
                </div>

                <div class="algorithm-step">
                    <span class="step-number">3</span>
                    <h4>Update Centroids</h4>
                    <p>Calculate new centroid as mean of all points in the cluster</p>
                </div>

                <div class="algorithm-step">
                    <span class="step-number">4</span>
                    <h4>Check Convergence</h4>
                    <p>If centroids didn't move (or moved very little), stop. Otherwise, go to step 2</p>
                </div>

                <div class="visual-demo">
                    <svg width="600" height="500" viewBox="0 0 600 500">
                        <!-- Title -->
                        <text x="300" y="20" text-anchor="middle" font-size="16" font-weight="bold" fill="#333">
                            K-Means Algorithm Iterations
                        </text>
                        
                        <!-- Iteration 0: Initial -->
                        <g transform="translate(0, 40)">
                            <text x="100" y="15" text-anchor="middle" font-size="12" font-weight="bold">Iteration 0: Initialize</text>
                            <rect x="20" y="25" width="160" height="120" fill="#f8f9fa" stroke="#ddd"/>
                            
                            <!-- Random centroids -->
                            <circle cx="50" cy="60" r="8" fill="#ec4899" stroke="#000" stroke-width="2"/>
                            <circle cx="120" cy="100" r="8" fill="#8b5cf6" stroke="#000" stroke-width="2"/>
                            <circle cx="150" cy="50" r="8" fill="#3b82f6" stroke="#000" stroke-width="2"/>
                            
                            <!-- Data points (gray) -->
                            <circle cx="45" cy="55" r="4" fill="#9ca3af"/>
                            <circle cx="55" cy="65" r="4" fill="#9ca3af"/>
                            <circle cx="115" cy="95" r="4" fill="#9ca3af"/>
                            <circle cx="125" cy="105" r="4" fill="#9ca3af"/>
                            <circle cx="145" cy="45" r="4" fill="#9ca3af"/>
                            <circle cx="155" cy="55" r="4" fill="#9ca3af"/>
                        </g>
                        
                        <!-- Iteration 1: First Assignment -->
                        <g transform="translate(200, 40)">
                            <text x="100" y="15" text-anchor="middle" font-size="12" font-weight="bold">Iteration 1: Assign</text>
                            <rect x="20" y="25" width="160" height="120" fill="#f8f9fa" stroke="#ddd"/>
                            
                            <!-- Centroids -->
                            <circle cx="50" cy="60" r="8" fill="#000" stroke="#ec4899" stroke-width="2"/>
                            <circle cx="120" cy="100" r="8" fill="#000" stroke="#8b5cf6" stroke-width="2"/>
                            <circle cx="150" cy="50" r="8" fill="#000" stroke="#3b82f6" stroke-width="2"/>
                            
                            <!-- Assigned points -->
                            <circle cx="45" cy="55" r="4" fill="#ec4899"/>
                            <circle cx="55" cy="65" r="4" fill="#ec4899"/>
                            <circle cx="115" cy="95" r="4" fill="#8b5cf6"/>
                            <circle cx="125" cy="105" r="4" fill="#8b5cf6"/>
                            <circle cx="145" cy="45" r="4" fill="#3b82f6"/>
                            <circle cx="155" cy="55" r="4" fill="#3b82f6"/>
                        </g>
                        
                        <!-- Iteration 2: Update Centroids -->
                        <g transform="translate(400, 40)">
                            <text x="100" y="15" text-anchor="middle" font-size="12" font-weight="bold">Iteration 2: Update</text>
                            <rect x="20" y="25" width="160" height="120" fill="#f8f9fa" stroke="#ddd"/>
                            
                            <!-- Updated centroids (moved) -->
                            <circle cx="50" cy="60" r="8" fill="#000" stroke="#ec4899" stroke-width="2"/>
                            <circle cx="120" cy="100" r="8" fill="#000" stroke="#8b5cf6" stroke-width="2"/>
                            <circle cx="150" cy="50" r="8" fill="#000" stroke="#3b82f6" stroke-width="2"/>
                            
                            <!-- Points stay assigned -->
                            <circle cx="45" cy="55" r="4" fill="#ec4899"/>
                            <circle cx="55" cy="65" r="4" fill="#ec4899"/>
                            <circle cx="115" cy="95" r="4" fill="#8b5cf6"/>
                            <circle cx="125" cy="105" r="4" fill="#8b5cf6"/>
                            <circle cx="145" cy="45" r="4" fill="#3b82f6"/>
                            <circle cx="155" cy="55" r="4" fill="#3b82f6"/>
                            
                            <!-- Show movement arrows -->
                            <path d="M 50 60 L 50 60" stroke="#000" stroke-width="1" marker-end="url(#arrow)"/>
                        </g>
                        
                        <!-- Final Result -->
                        <g transform="translate(200, 200)">
                            <text x="100" y="15" text-anchor="middle" font-size="12" font-weight="bold">Final: Converged!</text>
                            <rect x="20" y="25" width="160" height="120" fill="#f0fdf4" stroke="#22c55e" stroke-width="2"/>
                            
                            <!-- Final centroids -->
                            <circle cx="50" cy="60" r="8" fill="#000" stroke="#ec4899" stroke-width="2"/>
                            <circle cx="120" cy="100" r="8" fill="#000" stroke="#8b5cf6" stroke-width="2"/>
                            <circle cx="150" cy="50" r="8" fill="#000" stroke="#3b82f6" stroke-width="2"/>
                            
                            <!-- Final assignments -->
                            <circle cx="45" cy="55" r="4" fill="#ec4899"/>
                            <circle cx="55" cy="65" r="4" fill="#ec4899"/>
                            <circle cx="115" cy="95" r="4" fill="#8b5cf6"/>
                            <circle cx="125" cy="105" r="4" fill="#8b5cf6"/>
                            <circle cx="145" cy="45" r="4" fill="#3b82f6"/>
                            <circle cx="155" cy="55" r="4" fill="#3b82f6"/>
                            
                            <text x="100" y="170" text-anchor="middle" font-size="11" fill="#22c55e">‚úì Centroids stable</text>
                        </g>
                    </svg>
                </div>

                <div class="code-block">
# K-Means Algorithm Implementation from Scratch
import numpy as np
import matplotlib.pyplot as plt

class KMeans:
    def __init__(self, n_clusters=3, max_iters=100, random_state=42):
        self.n_clusters = n_clusters
        self.max_iters = max_iters
        self.random_state = random_state
        
    def fit(self, X):
        np.random.seed(self.random_state)
        
        # Step 1: Initialize centroids randomly
        idx = np.random.choice(len(X), self.n_clusters, replace=False)
        self.centroids = X[idx]
        
        for iteration in range(self.max_iters):
            # Step 2: Assign points to nearest centroid
            distances = self._calculate_distances(X)
            self.labels = np.argmin(distances, axis=1)
            
            # Step 3: Update centroids
            new_centroids = np.array([
                X[self.labels == k].mean(axis=0) 
                for k in range(self.n_clusters)
            ])
            
            # Step 4: Check convergence
            if np.allclose(self.centroids, new_centroids):
                print(f"Converged at iteration {iteration}")
                break
                
            self.centroids = new_centroids
            
        # Calculate final inertia (WCSS)
        self.inertia_ = self._calculate_inertia(X)
        return self
    
    def _calculate_distances(self, X):
        """Calculate distance from each point to each centroid"""
        distances = np.zeros((len(X), self.n_clusters))
        for k, centroid in enumerate(self.centroids):
            distances[:, k] = np.linalg.norm(X - centroid, axis=1)
        return distances
    
    def _calculate_inertia(self, X):
        """Calculate within-cluster sum of squares"""
        wcss = 0
        for k in range(self.n_clusters):
            cluster_points = X[self.labels == k]
            if len(cluster_points) > 0:
                wcss += np.sum((cluster_points - self.centroids[k])**2)
        return wcss
    
    def predict(self, X):
        """Predict cluster for new points"""
        distances = self._calculate_distances(X)
        return np.argmin(distances, axis=1)

# Example usage
np.random.seed(42)

# Generate sample data (3 clusters)
cluster1 = np.random.randn(100, 2) + [2, 2]
cluster2 = np.random.randn(100, 2) + [-2, -2]
cluster3 = np.random.randn(100, 2) + [2, -2]
X = np.vstack([cluster1, cluster2, cluster3])

# Apply K-Means
kmeans = KMeans(n_clusters=3)
kmeans.fit(X)

# Visualize results
plt.figure(figsize=(10, 6))
colors = ['#ec4899', '#8b5cf6', '#3b82f6']

for k in range(3):
    cluster_points = X[kmeans.labels == k]
    plt.scatter(cluster_points[:, 0], cluster_points[:, 1], 
               c=colors[k], alpha=0.6, label=f'Cluster {k+1}')

# Plot centroids
plt.scatter(kmeans.centroids[:, 0], kmeans.centroids[:, 1], 
           c='black', s=200, marker='*', edgecolor='white', linewidth=2,
           label='Centroids')

plt.title(f'K-Means Clustering (K=3, Inertia={kmeans.inertia_:.2f})')
plt.xlabel('Feature 1')
plt.ylabel('Feature 2')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()

print(f"Final Inertia (WCSS): {kmeans.inertia_:.2f}")
print(f"Cluster sizes: {[sum(kmeans.labels==k) for k in range(3)]}")
                </div>
            </div>

        </div>

        <!-- Implementation Section -->
        <div id="implementation" class="content-section">
            
            <div class="card">
                <h2 class="section-title">
                    <span class="icon-box">üíª</span>
                    Complete Implementation with Scikit-Learn
                </h2>

                <div class="code-block">
# Complete K-Means Implementation with Real Data
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.metrics import silhouette_score, calinski_harabasz_score
import warnings
warnings.filterwarnings('ignore')

# 1. CUSTOMER SEGMENTATION EXAMPLE
print("="*60)
print("CUSTOMER SEGMENTATION WITH K-MEANS")
print("="*60)

# Generate synthetic customer data
np.random.seed(42)
n_customers = 1000

# Create customer features
customer_data = pd.DataFrame({
    'annual_spending': np.concatenate([
        np.random.normal(30000, 5000, 300),   # Low spenders
        np.random.normal(60000, 8000, 400),   # Medium spenders
        np.random.normal(100000, 15000, 300)  # High spenders
    ]),
    'frequency': np.concatenate([
        np.random.poisson(5, 300),    # Rare shoppers
        np.random.poisson(15, 400),   # Regular shoppers
        np.random.poisson(30, 300)    # Frequent shoppers
    ]),
    'recency_days': np.concatenate([
        np.random.exponential(60, 300),   # Haven't shopped recently
        np.random.exponential(20, 400),   # Moderate recency
        np.random.exponential(5, 300)     # Very recent shoppers
    ]),
    'avg_purchase': np.concatenate([
        np.random.normal(50, 10, 300),    # Small purchases
        np.random.normal(150, 30, 400),   # Medium purchases
        np.random.normal(500, 100, 300)   # Large purchases
    ])
})

print("Customer Data Sample:")
print(customer_data.head())
print(f"\nShape: {customer_data.shape}")

# 2. PREPROCESSING
print("\n" + "="*60)
print("DATA PREPROCESSING")
print("="*60)

# Standardize features (important for K-Means!)
scaler = StandardScaler()
X_scaled = scaler.fit_transform(customer_data)

print("Features scaled to mean=0, std=1")
print(f"Scaled data shape: {X_scaled.shape}")

# 3. DETERMINE OPTIMAL K
print("\n" + "="*60)
print("FINDING OPTIMAL K")
print("="*60)

# Method 1: Elbow Method
inertias = []
silhouette_scores = []
K_range = range(2, 11)

for k in K_range:
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
    kmeans.fit(X_scaled)
    inertias.append(kmeans.inertia_)
    silhouette_scores.append(silhouette_score(X_scaled, kmeans.labels_))
    print(f"K={k}: Inertia={kmeans.inertia_:.2f}, Silhouette={silhouette_scores[-1]:.3f}")

# 4. FIT FINAL MODEL
print("\n" + "="*60)
print("FINAL MODEL (K=3)")
print("="*60)

# Fit with optimal K=3
final_kmeans = KMeans(n_clusters=3, random_state=42, n_init=10)
customer_data['cluster'] = final_kmeans.fit_predict(X_scaled)

# Analyze clusters
for cluster in range(3):
    print(f"\nCluster {cluster} Statistics:")
    cluster_data = customer_data[customer_data['cluster'] == cluster]
    print(f"Size: {len(cluster_data)} customers ({len(cluster_data)/len(customer_data)*100:.1f}%)")
    print(cluster_data.drop('cluster', axis=1).mean())

# 5. VISUALIZATIONS
fig, axes = plt.subplots(2, 3, figsize=(15, 10))

# Elbow curve
axes[0, 0].plot(K_range, inertias, 'bo-')
axes[0, 0].set_xlabel('Number of Clusters (K)')
axes[0, 0].set_ylabel('Inertia (WCSS)')
axes[0, 0].set_title('Elbow Method')
axes[0, 0].axvline(x=3, color='r', linestyle='--', alpha=0.5)
axes[0, 0].grid(True, alpha=0.3)

# Silhouette scores
axes[0, 1].plot(K_range, silhouette_scores, 'go-')
axes[0, 1].set_xlabel('Number of Clusters (K)')
axes[0, 1].set_ylabel('Silhouette Score')
axes[0, 1].set_title('Silhouette Analysis')
axes[0, 1].axvline(x=3, color='r', linestyle='--', alpha=0.5)
axes[0, 1].grid(True, alpha=0.3)

# Cluster visualization using PCA
pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_scaled)

colors = ['#ec4899', '#8b5cf6', '#3b82f6']
for cluster in range(3):
    cluster_points = X_pca[customer_data['cluster'] == cluster]
    axes[0, 2].scatter(cluster_points[:, 0], cluster_points[:, 1], 
                      c=colors[cluster], alpha=0.6, label=f'Cluster {cluster}')

# Plot centroids in PCA space
centroids_pca = pca.transform(final_kmeans.cluster_centers_)
axes[0, 2].scatter(centroids_pca[:, 0], centroids_pca[:, 1], 
                  c='black', s=200, marker='*', edgecolor='white', linewidth=2)
axes[0, 2].set_xlabel(f'PC1 ({pca.explained_variance_ratio_[0]:.1%} var)')
axes[0, 2].set_ylabel(f'PC2 ({pca.explained_variance_ratio_[1]:.1%} var)')
axes[0, 2].set_title('Clusters in PCA Space')
axes[0, 2].legend()
axes[0, 2].grid(True, alpha=0.3)

# Feature importance for each cluster
cluster_centers = scaler.inverse_transform(final_kmeans.cluster_centers_)
features = customer_data.columns[:-1]
x = np.arange(len(features))
width = 0.25

for i in range(3):
    axes[1, 0].bar(x + i*width, cluster_centers[i], width, 
                  label=f'Cluster {i}', color=colors[i])

axes[1, 0].set_xlabel('Features')
axes[1, 0].set_ylabel('Values')
axes[1, 0].set_title('Cluster Centers (Original Scale)')
axes[1, 0].set_xticks(x + width)
axes[1, 0].set_xticklabels(features, rotation=45)
axes[1, 0].legend()
axes[1, 0].grid(True, alpha=0.3)

# Spending vs Frequency scatter
for cluster in range(3):
    cluster_data = customer_data[customer_data['cluster'] == cluster]
    axes[1, 1].scatter(cluster_data['annual_spending'], 
                      cluster_data['frequency'],
                      c=colors[cluster], alpha=0.6, label=f'Cluster {cluster}')

axes[1, 1].set_xlabel('Annual Spending')
axes[1, 1].set_ylabel('Purchase Frequency')
axes[1, 1].set_title('Customer Segments')
axes[1, 1].legend()
axes[1, 1].grid(True, alpha=0.3)

# Cluster size pie chart
cluster_sizes = customer_data['cluster'].value_counts().sort_index()
axes[1, 2].pie(cluster_sizes, labels=[f'Cluster {i}' for i in range(3)],
              colors=colors, autopct='%1.1f%%', startangle=90)
axes[1, 2].set_title('Cluster Distribution')

plt.suptitle('K-Means Customer Segmentation Analysis', fontsize=16, y=1.02)
plt.tight_layout()
plt.show()

# 6. CLUSTER INTERPRETATION
print("\n" + "="*60)
print("CLUSTER INTERPRETATION")
print("="*60)

# Name clusters based on characteristics
cluster_names = {
    0: "Budget Conscious",
    1: "Regular Customers", 
    2: "VIP Customers"
}

for cluster in range(3):
    cluster_data = customer_data[customer_data['cluster'] == cluster]
    print(f"\n{cluster_names[cluster]} (Cluster {cluster}):")
    print(f"  - Size: {len(cluster_data)} customers")
    print(f"  - Avg Annual Spending: ${cluster_data['annual_spending'].mean():,.0f}")
    print(f"  - Avg Purchase Frequency: {cluster_data['frequency'].mean():.1f} times/year")
    print(f"  - Avg Days Since Last Purchase: {cluster_data['recency_days'].mean():.1f} days")
    print(f"  - Avg Purchase Amount: ${cluster_data['avg_purchase'].mean():,.0f}")

# 7. K-MEANS++ VS RANDOM INITIALIZATION
print("\n" + "="*60)
print("K-MEANS++ VS RANDOM INITIALIZATION")
print("="*60)

# Compare initialization methods
n_runs = 10
random_inertias = []
kmeanspp_inertias = []

for _ in range(n_runs):
    # Random initialization
    km_random = KMeans(n_clusters=3, init='random', n_init=1, 
                       random_state=np.random.randint(1000))
    km_random.fit(X_scaled)
    random_inertias.append(km_random.inertia_)
    
    # K-Means++ initialization
    km_plus = KMeans(n_clusters=3, init='k-means++', n_init=1,
                    random_state=np.random.randint(1000))
    km_plus.fit(X_scaled)
    kmeanspp_inertias.append(km_plus.inertia_)

print(f"Random Init - Mean Inertia: {np.mean(random_inertias):.2f} (¬±{np.std(random_inertias):.2f})")
print(f"K-Means++ - Mean Inertia: {np.mean(kmeanspp_inertias):.2f} (¬±{np.std(kmeanspp_inertias):.2f})")
print(f"K-Means++ is {(1 - np.mean(kmeanspp_inertias)/np.mean(random_inertias))*100:.1f}% better!")
                </div>
            </div>

        </div>

        <!-- Choosing K Section -->
        <div id="choosing-k" class="content-section">
            
            <div class="card">
                <h2 class="section-title">
                    <span class="icon-box">üî¢</span>
                    How to Choose the Optimal K
                </h2>

                <div class="concept-grid">
                    <div class="concept-card">
                        <h4>üìà Elbow Method</h4>
                        <p>Plot WCSS vs K, look for the "elbow" where decrease slows</p>
                        <p style="color: #10b981; margin-top: 10px;">‚úì Most common method</p>
                    </div>
                    <div class="concept-card">
                        <h4>üìä Silhouette Score</h4>
                        <p>Measures how similar points are to their cluster vs other clusters</p>
                        <p style="color: #3b82f6; margin-top: 10px;">Range: [-1, 1], higher is better</p>
                    </div>
                    <div class="concept-card">
                        <h4>üéØ Gap Statistic</h4>
                        <p>Compares WCSS to expected value under null hypothesis</p>
                        <p style="color: #8b5cf6; margin-top: 10px;">More rigorous but complex</p>
                    </div>
                    <div class="concept-card">
                        <h4>üíº Domain Knowledge</h4>
                        <p>Business requirements often dictate K</p>
                        <p style="color: #f59e0b; margin-top: 10px;">E.g., "We need 5 customer segments"</p>
                    </div>
                </div>

                <div class="interactive-demo">
                    <h3>Interactive K Selection</h3>
                    <div class="slider-container">
                        <label for="kValue">Number of Clusters (K): <span id="kDisplay">3</span></label>
                        <input type="range" id="kValue" class="slider" min="2" max="6" value="3" oninput="updateKMeans()">
                    </div>
                    <canvas id="clusterCanvas" width="500" height="300"></canvas>
                </div>

                <div class="code-block">
# Methods for Choosing Optimal K
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
from scipy.spatial.distance import cdist

# Generate sample data
np.random.seed(42)
X = np.random.randn(300, 2)
X[:100] += [2, 2]
X[100:200] += [-2, -2]
X[200:] += [2, -2]

# 1. ELBOW METHOD
wcss = []
K_range = range(1, 11)

for k in K_range:
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(X)
    wcss.append(kmeans.inertia_)

# 2. SILHOUETTE ANALYSIS
silhouette_scores = []

for k in range(2, 11):  # Start from 2 (need at least 2 clusters)
    kmeans = KMeans(n_clusters=k, random_state=42)
    labels = kmeans.fit_predict(X)
    silhouette_scores.append(silhouette_score(X, labels))

# 3. GAP STATISTIC
def gap_statistic(X, max_k=10, n_refs=10):
    gaps = []
    sks = []
    
    for k in range(1, max_k + 1):
        # Cluster original data
        kmeans = KMeans(n_clusters=k, random_state=42)
        kmeans.fit(X)
        
        # Calculate WCSS for original data
        wcss_orig = kmeans.inertia_
        
        # Generate reference datasets and calculate WCSS
        wcss_refs = []
        for _ in range(n_refs):
            # Random data with same bounds as original
            X_ref = np.random.uniform(X.min(axis=0), X.max(axis=0), size=X.shape)
            kmeans_ref = KMeans(n_clusters=k, random_state=42)
            kmeans_ref.fit(X_ref)
            wcss_refs.append(kmeans_ref.inertia_)
        
        # Calculate gap statistic
        gap = np.log(np.mean(wcss_refs)) - np.log(wcss_orig)
        gaps.append(gap)
        
        # Calculate standard error
        sk = np.std(np.log(wcss_refs)) * np.sqrt(1 + 1/n_refs)
        sks.append(sk)
    
    return gaps, sks

gaps, sks = gap_statistic(X, max_k=10)

# Visualization
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# Elbow Method
axes[0].plot(K_range, wcss, 'bo-')
axes[0].set_xlabel('Number of Clusters (K)')
axes[0].set_ylabel('WCSS (Inertia)')
axes[0].set_title('Elbow Method')
axes[0].axvline(x=3, color='r', linestyle='--', label='Optimal K=3')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# Add elbow point annotation
elbow_point = 3  # Visually determined
axes[0].annotate('Elbow', xy=(elbow_point, wcss[elbow_point-1]), 
                xytext=(elbow_point+1, wcss[elbow_point-1]+500),
                arrowprops=dict(arrowstyle='->', color='red'),
                fontsize=12, color='red')

# Silhouette Score
axes[1].plot(range(2, 11), silhouette_scores, 'go-')
axes[1].set_xlabel('Number of Clusters (K)')
axes[1].set_ylabel('Silhouette Score')
axes[1].set_title('Silhouette Analysis')
axes[1].axvline(x=3, color='r', linestyle='--', label='Optimal K=3')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

# Highlight max silhouette
max_idx = np.argmax(silhouette_scores)
axes[1].scatter(max_idx+2, silhouette_scores[max_idx], 
               color='red', s=100, zorder=5)

# Gap Statistic
axes[2].errorbar(range(1, 11), gaps, yerr=sks, marker='o', capsize=5)
axes[2].set_xlabel('Number of Clusters (K)')
axes[2].set_ylabel('Gap Statistic')
axes[2].set_title('Gap Statistic Method')
axes[2].axvline(x=3, color='r', linestyle='--', label='Optimal K=3')
axes[2].legend()
axes[2].grid(True, alpha=0.3)

plt.suptitle('Methods for Determining Optimal K', fontsize=16, y=1.02)
plt.tight_layout()
plt.show()

print("Optimal K Summary:")
print(f"Elbow Method suggests: K = 3")
print(f"Silhouette Score suggests: K = {np.argmax(silhouette_scores) + 2}")
print(f"Gap Statistic suggests: K = {np.argmax(gaps) + 1}")
                </div>
            </div>

        </div>

        <!-- Real World Section -->
        <div id="realworld" class="content-section">
            
            <div class="card">
                <h2 class="section-title">
                    <span class="icon-box">üåç</span>
                    Real-World Applications
                </h2>

                <div class="real-example">
                    <h4 style="color: #312e81;">üõçÔ∏è Customer Segmentation (Retail)</h4>
                    <p><strong>Problem:</strong> Group customers for targeted marketing</p>
                    <p><strong>Features:</strong> RFM (Recency, Frequency, Monetary value), demographics, purchase history</p>
                    <p><strong>Typical K:</strong> 4-6 segments (VIP, Regular, At-risk, Lost)</p>
                    <p><strong>Impact:</strong> 20-30% increase in marketing ROI through personalization</p>
                </div>

                <div class="real-example">
                    <h4 style="color: #312e81;">üñºÔ∏è Image Compression</h4>
                    <p><strong>Problem:</strong> Reduce image file size by color quantization</p>
                    <p><strong>Features:</strong> RGB pixel values</p>
                    <p><strong>Typical K:</strong> 16-256 colors (depends on quality needs)</p>
                    <p><strong>Impact:</strong> 70-90% file size reduction with minimal quality loss</p>
                </div>

                <div class="real-example">
                    <h4 style="color: #312e81;">üìç Geographic Clustering</h4>
                    <p><strong>Problem:</strong> Optimize delivery routes or store locations</p>
                    <p><strong>Features:</strong> Latitude, longitude, demand density</p>
                    <p><strong>Typical K:</strong> Number of delivery hubs or stores</p>
                    <p><strong>Impact:</strong> 15-25% reduction in delivery costs</p>
                </div>

                <div class="real-example">
                    <h4 style="color: #312e81;">üìÑ Document Clustering</h4>
                    <p><strong>Problem:</strong> Organize documents by topic</p>
                    <p><strong>Features:</strong> TF-IDF vectors, word embeddings</p>
                    <p><strong>Typical K:</strong> 10-50 topics (depends on corpus)</p>
                    <p><strong>Impact:</strong> 60% faster document retrieval</p>
                </div>

                <div class="real-example">
                    <h4 style="color: #312e81;">üè• Patient Segmentation (Healthcare)</h4>
                    <p><strong>Problem:</strong> Group patients for personalized treatment</p>
                    <p><strong>Features:</strong> Symptoms, test results, medical history</p>
                    <p><strong>Typical K:</strong> 3-5 risk groups</p>
                    <p><strong>Impact:</strong> 30% better treatment outcomes</p>
                </div>

                <div class="code-block">
# Real-World Example: Image Compression with K-Means
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from PIL import Image
import requests
from io import BytesIO

# Load a sample image (you can use any image)
# Creating a synthetic image for demonstration
np.random.seed(42)
image = np.random.rand(100, 100, 3)

# Add some patterns to make it interesting
for i in range(0, 100, 20):
    image[i:i+10, :, 0] = 0.8
    image[:, i:i+10, 1] = 0.6
    
image[40:60, 40:60] = [1, 0.5, 0]  # Orange square

print("Original Image Shape:", image.shape)
print(f"Original Colors: {len(np.unique(image.reshape(-1, 3), axis=0))} unique colors")

# Function to compress image using K-Means
def compress_image(image, n_colors):
    # Reshape image to be a list of pixels
    pixels = image.reshape(-1, 3)
    
    # Apply K-Means
    kmeans = KMeans(n_clusters=n_colors, random_state=42)
    kmeans.fit(pixels)
    
    # Replace each pixel with its cluster center
    compressed_pixels = kmeans.cluster_centers
